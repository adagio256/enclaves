"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VsockSocket = exports.VsockServer = void 0;
const events_1 = require("events");
const addon_1 = require("./addon");
class VsockServer extends events_1.EventEmitter {
    constructor() {
        super();
        this.listening = false;
        this.closed = false;
        this.onError = (err) => {
            process.nextTick(() => {
                // unhandled error emitted from emitter will cause stopping process.
                // server have to listen on 'error' event to bypass this problem now.
                this.emit('error', err);
            });
        };
        this.onConnection = (fd) => {
            const socket = new VsockSocket(fd);
            this.emit('connection', socket);
        };
        const emit = (this.emit = this.emit.bind(this));
        this.socket = new addon_1.VsockSocket(function (err, eventName, ...args) {
            if (err) {
                err.message += `(server socket event: ${eventName})`;
                emit('error', err);
            }
            else {
                emit(eventName, ...args);
            }
        });
        this.on('_connection', this.onConnection);
        this.on('_error', this.onError);
    }
    close() {
        if (this.closed) {
            return;
        }
        this.listening = false;
        this.closed = true;
        this.socket.close();
    }
    listen(port) {
        if (this.closed) {
            throw new Error('Socket has been closed');
        }
        this.socket.listen(port);
        this.listening = true;
    }
}
exports.VsockServer = VsockServer;
class VsockSocket extends events_1.EventEmitter {
    constructor(fd) {
        super();
        this.destroyed = false;
        this.connecting = false;
        this.isShutdown = false;
        this.isEnd = false;
        this.onData = (buf) => {
            this.emit('data', buf);
        };
        this.onError = (err) => {
            process.nextTick(() => {
                // unhandled error emitted from emitter will cause stopping process.
                // incoming socket have to listen on 'error' event to bypass this problem now.
                this.emit('error', err);
            });
        };
        this.onEnd = () => {
            this.isEnd = true;
            this.tryClose();
        };
        this.onShutdown = () => {
            this.isShutdown = true;
            this.tryClose();
            if (this.shutdownCallback) {
                this.shutdownCallback();
            }
        };
        this.onConnect = () => {
            this.connecting = false;
            this.emit('connect');
            this.socket.startRecv();
            if (this.connectCallback) {
                this.connectCallback();
            }
        };
        const emit = (this.emit = this.emit.bind(this));
        this.socket = new addon_1.VsockSocket(function (err, eventName, ...args) {
            if (err) {
                err.message += `(socket event: ${eventName})`;
                emit('error', err);
            }
            else {
                emit(eventName, ...args);
            }
        }, fd);
        if (fd) {
            this.socket.startRecv();
        }
        this.on('_data', this.onData);
        this.on('_connect', this.onConnect);
        this.on('_error', this.onError);
        this.on('_shutdown', this.onShutdown);
        this.on('end', this.onEnd);
    }
    connect(cid, port, connectCallback) {
        this.checkDestroyed();
        this.connecting = true;
        this.connectCallback = connectCallback;
        this.socket.connect(cid, port);
    }
    writeSync(buf) {
        this.checkDestroyed();
        this.socket.writeBuffer(buf);
    }
    writeTextSync(data) {
        this.checkDestroyed();
        this.socket.writeText(data);
    }
    end(callback) {
        this.shutdownCallback = callback;
        this.socket.end();
    }
    destroy() {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        this.socket.close();
    }
    checkDestroyed() {
        if (this.destroyed) {
            throw new Error('Socket has been destroyed');
        }
    }
    tryClose() {
        if (this.isEnd && this.isShutdown) {
            this.destroy();
        }
    }
}
exports.VsockSocket = VsockSocket;
